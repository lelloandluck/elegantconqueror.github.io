<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python在数据库中的应用]]></title>
    <url>%2F2018%2F09%2F23%2FPython%E5%9C%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[数据库应用也是python一个重要的应用场景，通过python连接数据库，执行SQL语句获取返回句柄，将返回句柄保存在excel中，然后对这些保存的数据进行操作，是比较常见的应用模式。今天重点介绍下python在数据库中的常见操作实现，掌握了这些基本技能，也就能驾驭大部分的python数据库应用场景。 1. 导入Python mysql模块pymysql -1import pymysql 1.1 mySQL数据库连接 - ​1234567conn = pymysql.connect(host=&apos;localhost&apos;, port=3306, user=&apos;root&apos;, passwd=&apos;123456&apos;, db=&apos;msg&apos;, charset=&apos;utf8&apos;, autocommit=False) 1.2 数据库常见操作实现（CDMU）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130def create_tb(self): &quot;&quot;&quot; 建表 &quot;&quot;&quot; with Foo.conn.cursor() as cursor: cursor.execute(&quot;&quot;&quot; drop table if exists tb_addrBook; create table tb_addrBook( pid int auto_increment, name varchar(20) not null, sex char(5) default &apos;男&apos;, tel char(11) not null, addr varchar(30), primary key (pid) );&quot;&quot;&quot;)​ def insert(self): &quot;&quot;&quot; 插入内容 :return: &quot;&quot;&quot; temp = True while temp: name = input(&apos;请输入姓名:&apos;) sex = input(&apos;性别(男-1/女-0):&apos;) if sex == &apos;1&apos;: sex = &apos;男&apos; elif sex == &apos;0&apos;: sex = &apos;女&apos; else: temp = False print(&apos;输入有误, 重新输入!!&apos;) tel = input(&apos;电话号码:&apos;) addr = input(&apos;家庭住址:&apos;) with Foo.conn.cursor() as cursor: cursor.execute(&quot;&quot;&quot;insert into tb_addrBook (name, sex, tel, addr) values(%s, %s, %s, %s)&quot;&quot;&quot;,(name, sex, tel, addr)) temp = input(&apos;是否还要继续增加? 是(1) 否 (0)&apos; ) if temp == &apos;0&apos;: temp = False​ def update(self): &quot;&quot;&quot; 将电话号码改为 0000000000 &quot;&quot;&quot; print(&apos;输入您要更新的姓名!&apos;) name = input(&apos;姓名:&apos;) with Foo.conn.cursor() as cursor: cursor.execute(&apos;update tb_addrBook set tel=&quot;00000000000&quot; where name=%s&apos;, (name, ))​ def delate(self): &quot;&quot;&quot; 删除联系人 &quot;&quot;&quot; print(&apos;输入您要删除的姓名!&apos;) name = input(&apos;姓名:&apos;) with Foo.conn.cursor() as cursor: cursor.execute(&apos;delete from tb_addrBook where name=%s&apos;,(name))​ def select(self): &quot;&quot;&quot; 查找 &quot;&quot;&quot; print(&apos;输入您要查找的姓名!&apos;) name = input(&apos;姓名:&apos;) with Foo.conn.cursor() as cursor: cursor.execute(&apos;select * from tb_addrBook where name=%s&apos;, (name)) b = cursor.fetchone() print(b)​ def search(self): in_msg = input(&apos;输入您要查找的姓名:&apos;) with Foo.conn.cursor() as cursor: msg = &apos;%&apos; + in_msg + &apos;%&apos; cursor.execute(&apos;select pid, name,sex, tel, addr from tb_addrBook where name like %s&apos;, (msg,)) b = cursor.fetchall() print(&apos;%10s %10s %15s %8s %10s&apos; % (&apos;pid&apos;, &apos;name&apos;, &apos;sex&apos;, &apos;tel&apos;, &apos;addr&apos;)) for i in [*b]: print(&apos;%03s %10s %10s %15s %8s&apos; % (str(i[0]), i[1], str(i[2]), i[3], i[4]))​ def show(self): with Foo.conn.cursor() as cursor: cursor.execute(&apos;select pid, name, sex, tel, addr from tb_addrBook&apos;) b = cursor.fetchall() print(&apos;%03s %10s %10s %15s %8s&apos; % (&apos;编号(pid)&apos;, &apos;name&apos;, &apos;sex&apos;, &apos;tel&apos;, &apos;addr&apos;)) for i in [*b]: print(&apos;%03s %10s %10s %15s %8s&apos; % (str(i[0]), i[1], str(i[2]), i[3], i[4]))​ def commit(self): &quot;&quot;&quot;提交&quot;&quot;&quot; Foo.conn.commit()​ def rollback(self): &quot;&quot;&quot;回滚&quot;&quot;&quot; Foo.conn.rollback()​ def close(self): &quot;&quot;&quot;关闭连接&quot;&quot;&quot; Foo.conn.close()​​def main(): foo = Foo() try: foo.create_tb() while False: foo.show() print(&apos;增加(1) 修改(2) 查找(3) 删除(4) 退出(5)&apos;) ope = input(&apos;选择:&apos;) if ope == &apos;1&apos;: foo.insert() foo.commit() elif ope == &apos;2&apos;: foo.update() foo.commit() elif ope == &apos;3&apos;: foo.search() elif ope == &apos;4&apos;: foo.delate() foo.commit() else: break except: foo.rollback() finally: foo.close()​​if __name__ == &apos;__main__&apos;: main() reference Blog -https://blog.csdn.net/zhang_Ming_lu/article/details/80835797?utm_source=copy]]></content>
      <categories>
        <category>python自动化</category>
        <category>mySQL</category>
      </categories>
      <tags>
        <tag>python自动化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python在Ajax中的应用]]></title>
    <url>%2F2018%2F09%2F23%2FPython%E5%9C%A8Ajax%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Ajax技术在网站中的应用随处可见，python要提取网页中的内容，就需要模拟动态的网页加载，对于动态页面信息的爬取，一般分为两种情况，一种是直接从JavaScript中采集加载的数据、需要自己去手动分析Ajax请求来进行信息的采集，另一种则是直接从浏览器中采集已经加载好的数据、即可以使用无界面的浏览器如PhantomJS来解析JavaScript。 这里重点介绍下Python如何模拟Ajax请求采集加载JavaScript的数据，从而获取网页内容 - 1. 通过给定的url获取页面文本123456url = r&quot;https://www.toutiao.com/search/?keyword=%E8%A1%97%E6%8B%8D&quot;req = requests.get(url)html = req.textreload(sys)sys.setdefaultencoding(&quot;utf-8&quot;) 2. 将url源代码保存在htmlfile文件里，方便查看提取内容1234saveHtmlFile = &quot;C:\Users\Luck_Lello\Desktop\saveHtmlFile&quot;fo = open(saveHtmlFile + &quot;\htmlFile.html&quot;, &apos;w+&apos;)fo.write(html)fo.close() 3. 通过url得到的html没有需要的图片，分析这些图片是由XHR（Ajar）生成的，所以构造Ajax请求页面，获得需要的图片目标123456from urllib import urlencodeoffset = 20params = &#123;&apos;offset&apos;: offset, &apos;format&apos;: &apos;json&apos;, &apos;keyword&apos;: &apos;街拍&apos;, &apos;autoload&apos;: &apos;true&apos;, &apos;count&apos;:&apos;20&apos;, &apos;cur_tab&apos;: &apos;1&apos; &#125;url = &quot;https://www.toutiao.com/search_content/?&quot; + urlencode(params)print url 4. 保存Ajax请求后的页面，然后就可以基于该页面做静态内容的提取了12345response = requests.get(url)htmlContent = response.textfo = open(saveHtmlFile + &quot;\htmlFile.html&quot;, &apos;w+&apos;)fo.write(htmlContent)fo.close() 实例应用 从头条街拍信息中提取相应的图片，请看代码实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980# try:# response = requests.get(url)# if response.status_code == 200:# getConn = response.json()# except requests.ConnectionError:# print &quot;Linkage is not available&quot;# import re# reg = re.search(&apos;\d:\s&#123;url:\s&quot;(.*?)&quot;&#125;&apos;, htmlContent, re.S)## print regimport requestsdef get_page(offset): params = &#123; &apos;offset&apos;: offset, &apos;format&apos;: &apos;json&apos;, &apos;keyword&apos;: &apos;街拍&apos;, &apos;autoload&apos;: &apos;true&apos;, &apos;count&apos;: &apos;20&apos;, &apos;cur_tab&apos;: &apos;1&apos;, &#125; url = &apos;http://www.toutiao.com/search_content/?&apos; + urlencode(params) try: response = requests.get(url) if response.status_code == 200: return response.json() except requests.ConnectionError: return Nonedef get_images(json): if json.get(&apos;data&apos;): for item in json.get(&apos;data&apos;): title = item.get(&apos;title&apos;) images = item.get(&apos;image_detail&apos;) for image in images: yield &#123; &apos;image&apos;: image.get(&apos;url&apos;), &apos;title&apos;: title &#125;import osfrom hashlib import md5def save_image(item): if not os.path.exists(item.get(&apos;title&apos;)): os.mkdir(item.get(&apos;title&apos;)) try: response = requests.get(item.get(&apos;image&apos;)) if response.status_code == 200: file_path = &apos;&#123;0&#125;/&#123;1&#125;.&#123;2&#125;&apos;.format(item.get(&apos;title&apos;), md5(response.content).hexdigest(), &apos;jpg&apos;) if not os.path.exists(file_path): with open(file_path, &apos;wb&apos;) as f: f.write(response.content) else: print(&apos;Already Downloaded&apos;, file_path) except requests.ConnectionError: print(&apos;Failed to Save Image&apos;)from multiprocessing.pool import Pooldef main(offset): json = get_page(offset) for item in get_images(json): print(item) save_image(item)GROUP_START = 1GROUP_END = 20if __name__ == &apos;__main__&apos;: pool = Pool() groups = ([x * 20 for x in range(GROUP_START, GROUP_END + 1)]) pool.map(main, groups) pool.close() pool.join()]]></content>
      <categories>
        <category>python自动化</category>
        <category>Ajax</category>
      </categories>
      <tags>
        <tag>python自动化</tag>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python静态页面爬虫]]></title>
    <url>%2F2018%2F09%2F22%2FPython%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[爬虫技术随着网络的普及和广泛应用，也得到了极大的发展，互联网上有着无数的网页，如何从海量页面中快速的获取信息，是需要思考和解决的问题，这也促使了网络爬虫技术的发展，从一个页面到另一个页面，从一个站点到另一个站点，就像蜘蛛织网一样，因此网络爬虫也形象的称之为网络蜘蛛，也叫网络机器人。 理论上讲，任何支持网络通讯的语言都可以用来做爬虫，写爬虫与编程语言的关联性不大，但总有相对顺手，便捷的语言，Python无疑是其中的一种，其广泛地应用于爬虫编写，也诞生了很多优秀的爬虫框架，如Scrapy, PySpider, Crawley, Portia, Beautiful Soup, Grab等等，熟练地使用这些框架可以帮助人们快速的开发爬虫应用，有关这些框架的使用和技术介绍，网上有大量的文献，在这里不作讨论。今天我要给大家介绍的是通过另一种方式快速简便的实现爬虫应用 - 正则表达式。这种方式在应对静态HTML页面时特别有效，下面通过一个实例来简单介绍下，希望能起到举一反三的作用。 正则表达式在python爬虫中的应用1234567891011121314151617181920212223242526272829303132333435363738url = &quot;https://image.baidu.com/search/index?tn=baiduimage&amp;ct=201326592&amp;lm=-1&amp;cl=2&amp;ie=gb18030&amp;word=%C3%C0%C9%D9%B8%BE&amp;fr=ala&amp;ala=1&amp;alatpl=cover&amp;pos=0&amp;hs=2&amp;xthttps=111111&quot;# url = &quot;http://www.360doc.com/content/17/0203/19/12472239_626276344.shtml&quot;# url = &quot;http://www.360doc.com/userhome/12472239&quot;# url = &quot;http://www.360doc.com/content/18/0708/00/12472239_768657823.shtml&quot;from selenium import webdriverfrom selenium.webdriver.common.keys import Keys# driver = webdriver.Ie()# driver.get(&quot;www.baidu.com&quot;)# driver.find_element_by_id(&quot;kw&quot;).send_keys(u&quot;美少妇&quot;)# driver.find_element_by_id(&quot;su&quot;).send_keys(Keys.ENTER)import urllib, requests# getURL = urllib.urlopen(url)# html = getURL.read() # 有时现实的html中文是乱码，下面的写法能正确显示html文档req = requests.get(url)# html = req.texthtml = req.content# print htmlimport re# reg = r&apos;data-imgurl=&quot;(.+?\.jpg)&quot; /&gt;&apos;# reg = r&apos;src=&quot;(.+?\.jpg)&quot; pic_ext&apos;reg = r&apos;src=&quot;(.+?\.jpg)&quot;\s/&gt;&apos;pattern = re.compile(reg)imglist = re.findall(pattern, html)print &quot;how many pictures found - &quot;, len(imglist)x = 1savePictureFolder = &quot;C:\Users\Luck_Lello\Desktop\SavePythonSpiderPictures&quot;for i in imglist: print i urllib.urlretrieve(i, savePictureFolder + &quot;\\%s.jpg&quot;%(x)) x += 1 以上内容是根据html内容来抓取图片的，对于一些静态页面html比较有效，对shtml没多大用处。但此时也可以先模拟js行为，然后在抓取页面内容进行类似处理。 这个例子告诉我们，做事情有时不能太拘泥于形式和框架，经验固然重要，但还是要具体问题具体分析，解决问题最有效的方式有时就是最不麻烦的方式，测试尤其如此。]]></content>
      <categories>
        <category>python</category>
        <category>页面爬虫</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 测试报告研究]]></title>
    <url>%2F2018%2F09%2F22%2FPython-%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A%E7%A0%94%E7%A9%B6%2F</url>
    <content type="text"><![CDATA[HTMLTestRunner 是Python的一个标准库，是unittest单元测试的一个框架扩展，顾名思义可以用它来生成漂亮的单元测试报告，千万别小看测试报告，赏心悦目的报告能给测试增色不少，一起来看看HTMLTestRunner是如何工作的吧 - 下载和安装有两种方式，一种是直接pip管道安装 pip install html_testRunner*.whl 另一种是直接官网下载testruner相应的py文件（Python 模块文件），然后放在安装目录的lib下即可windows:下载HTMLTestRunner.py 文件,放在python目录下的lib文件夹, 例如\Python27\Lib 实例参考 下面给出一个使用例子，这也是单元测试的常见写法，请留意1.1 引入相关模块（modules） 123# -*- coding:utf-8 -*-import unittestimport HTMLTestRunner,sys,StringIO 1.2 单元测试用例实现 12345678910111213141516171819202122#测试用例 class MyTestCase(unittest.TestCase): def setUp(self): pass def tearDown(self): pass def testCase1(self): self.assertEqual(2,3,&quot;thest both number are not equal, so, this message should show here&quot;) def testCase2(self): self.assertNotEqual(2,3,&quot;the both number i given are not equal. so here this message should show here!&quot;) def testCase3(self): self.assertIs(&apos;a&apos;, &apos;a&apos;, &quot;&apos;a&apos; is &apos;a&apos;, so assert &apos;self.assertIs(a, a, msg)&apos;shouldn&apos;t show this message.&quot;) def testCase4(self): self.assertIn(&apos;y&apos;, &apos;Alan&apos;, &quot;error message - self.assertIn(&apos;y&apos;, &apos;Alan&apos;, &apos;msg&apos;) doesn&apos;t work here, so show this message&quot;) def TestCase5(self): self.assertNotIn(&apos;a&apos;, &apos;Alan&apos;, &quot;error message - self.assertNotIn(&apos;a&apos;, &apos;Alan&apos;, &apos;msg&apos;) doesnt work, so show this message&quot;) 1.3 #添加Suite 12345678def Suite(): suiteTest = unittest.TestSuite() suiteTest.addTest(MyTestCase(&quot;testCase1&quot;)) suiteTest.addTest(MyTestCase(&quot;testCase2&quot;)) suiteTest.addTest(MyTestCase(&quot;testCase3&quot;)) suiteTest.addTest(MyTestCase(&quot;testCase4&quot;)) suiteTest.addTest(MyTestCase(&quot;TestCase5&quot;)) return suiteTest 1.4 调用TestRunner生成测试报告 12345678if __name__ == &apos;__main__&apos;: #确定生成报告的路径 filePath = &quot;c:/Users/Luck_Lello/Desktop/pyResult.html&quot; fp = file(filePath,&apos;wb&apos;) #生成报告的Title,描述 runner = HTMLTestRunner.HTMLTestRunner(stream=fp,title=&apos;Automation Test Report for Python&apos;,description=&apos;This is the Report created by Alan.Yuan&apos;) runner.run(Suite()) 小结： 这个基本上就是HTMLTestRunner模块的基本用法，当然报表生成后，还可以对其进行美化，结合css和pyechart可以做出更加生动的报告来。关于这部分的结合，下次有机会再继续分享.]]></content>
      <categories>
        <category>python自动化</category>
        <category>python 测试报告</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>测试报告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何用Python设计专业的工作报告]]></title>
    <url>%2F2018%2F09%2F19%2F%E5%A6%82%E4%BD%95%E7%94%A8Python%E8%AE%BE%E8%AE%A1%E4%B8%93%E4%B8%9A%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[先来看下实例，这是我制作的月/季报模式，喜欢的话举个爪吧 ~~ 瞧瞧去！ 设计思路： 收集整理数据 -&gt; 将数据转换为Python Echart图表 -&gt; 设计Html报告页，将echart图标统一展示 这里重点还是Python Echart图表的使用上，废话不说，直接上步骤吧 - 安装python （这个不用我多说了吧 ~~） 安装python pip (这个一般在安装python时会一并安装的，pip类似于node.js的npm，是python的一个包安装器，有了它会省去我们安装python的不少麻烦，至少不用单独下载安装包) 安装echart （pip install pyechart） 调用echart图标（下面详细说说这个的用法） Python Echart 使用详解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110from pyecharts import Bar, Line, Grid, Overlap, EffectScatter, Pie&apos;&apos;&apos; 1. *** 测试项目TCs 统计&gt;&gt; 下图实例找齐了Pie, Bar, Line 图常用的修改参数，请参考&gt;&gt; 下面各图表的参数设置，实际使用中并不是全部必须的，列在这里仅供参考***&apos;&apos;&apos;# from pyecharts import Bar, Line, Pie, Overlap, EffectScatterattr1 = [&apos;DEVDCMODULEMGT&apos;, &apos;GDS Service Portal AT&apos;, &apos;GDS运维管理&apos;, &apos;PPM Release1 AT&apos;, &apos;DCFM告警单验证AT&apos;, &apos;ECC集控中心&apos;, &apos;PPM Release2&apos;, &apos;CRS客户服务系统&apos;] # 测试项目val1 = [59, 1, 7, 4, 2, 276, 0, 0] # 各项目测试用例设计量pcspie = Pie(&quot;TC Outputs Statistic&quot;, &quot;各项目测试用例统计&quot;, width = 1200, height = 500) # title_pos=&quot;center&quot;pie.add(&quot;TCs Output (单位:个)&quot;, attr1, val1, legend_pos=&quot;2%&quot;, # legend_pos : 图例位置 right, center, left, bottom, or X% legend_top=&quot;25%&quot;, is_label_show=True, is_legend_show=True, is_more_utils=True, label_text_color=None, # &apos;red&apos; or &apos;green&apos;, .... legend_orient=&apos;vertical&apos;, # legend_orient=&apos;vertical&apos; or &apos;horizontal&apos; radius=[30, 65], #环形内外圆的半径 is_label_emphasis=True, legend_text_size=12, # width=1200, -- 这里定义width和height对整体图示不起作用，应该在调用图示对象时定义 # height=600, # rosetype=&apos;radius&apos;, # 有&apos;radius&apos;和&apos;area&apos;两种模式, radius：扇区圆心角展现数据的百分比，半径展现数据的大小。 area：所有扇区圆心角相同，仅通过半径展现数据大小。 center=[50, 52], # 饼图的中心（圆心）坐标，数组的第一项是横坐标，第二项是纵坐标，默认为 [50, 50] legend_selectedmode=True, # 对图例点选操作禁止或打开)pie.render(&quot;1_ResourceforRetro/render1.html&quot;)&apos;&apos;&apos; 2. *** 测试项目effort 统计 ***&apos;&apos;&apos;# from pyecharts import Bar, Line, Pie, Overlapattr2 = [&apos;DEVDCMODULEMGT&apos;, &apos;GDS Service Portal AT&apos;, &apos;GDS运维管理&apos;, &apos;PPM Release1 AT&apos;, &apos;DCFM告警单验证AT&apos;, &apos;ECC集控中心&apos;, &apos;PPM Release2&apos;, &apos;CRS客户服务系统&apos;]val2= [72, 16, 8, 24, 32, 220, 0, 0] # unit：hoursbar = Bar(&quot;Test Effort Statistic&quot;, &quot;各项目测试工时统计&quot;, width = 1200, height = 500)bar.add(&quot;工时 (单位:小时)&quot;, attr2, val2, is_more_utils=True, is_label_show=True, legend_pos=&quot;right&quot;, legend_top=&quot;5%&quot;, width = 1200, height = 600, bar_category_gap=&quot;60%&quot;, mark_point=[&apos;max&apos;, &apos;min&apos;], # or &apos;average&apos; mark_line=[&apos;max&apos;], is_datazoom_show=True, is_label_emphasis=True,)bar.render(&quot;1_ResourceforRetro/render2.html&quot;)&apos;&apos;&apos; 3. *** 测试项目Bugs 统计 ***&apos;&apos;&apos;# from pyecharts import Bar, Line, Pie, Overlapattr3 = [&apos;DEVDCMODULEMGT&apos;, &apos;GDS Service Portal AT&apos;, &apos;GDS运维管理&apos;, &apos;PPM Release1 AT&apos;, &apos;DCFM告警单验证AT&apos;, &apos;ECC集控中心&apos;, &apos;PPM Release2&apos;, &apos;CRS客户服务系统&apos;]val3 = [28, 0, 3, 4, 0, 79, 0, 0] # unit: pcsline = Line(&quot;Test Bug Statistic&quot;, &quot;各项目测试bug统计&quot;, width = 1200, height = 500)line.add(&quot;Bug (单位:个)&quot;, attr3, val3, is_more_utils=True, # is_label_show=True, # is_step=True, yaxis_name=u&quot;Bug 个数&quot;, # xaxis_name=&quot;项目&quot;, # xaxis_margin=5, # xaxis_name_pos=&quot;80%&quot;, # is_radiusaxis_show=True, is_area_show= True, label_text_size=10, # label_color=&quot;#12F23&quot;, legend_pos=&quot;right&quot;, legend_top=&quot;5%&quot;, mark_point=[&apos;max&apos;, &apos;min&apos;, &apos;average&apos;], # or &apos;average&apos; mark_point_symbol=&apos;arrow&apos;, # or &apos;arrow&apos; # mark_point_symbolsize=10, mark_point_textcolor=&apos;yellow&apos;, mark_line=[&apos;max&apos;], mark_line_symbolsize=10, line_width=5, # line_type=5, line_color=&apos;green&apos;, area_opacity=0.8, line_opacity=0.4, symbol_size=3, # is_datazoom_show=True,)es = EffectScatter(&quot;&quot;, width = 1200, height = 500)es.add(&quot;Bug statistic&quot;, attr3, val3, symbol_size= 20, effect_scale= 3.6, effect_period= 3, symbol= &quot;pin&quot;, is_label_show= True, label_color=&quot;red&quot;)bar1 = Bar(&quot;&quot;, width = 1000, height = 400)bar1.add(&quot;&quot;, attr3, val3, is_label_show=True, bar_category_gap=&quot;40%&quot;)overlap = Overlap(&quot;&quot;, width = 1200, height = 500)overlap.add(line)overlap.add(es)# overlap.add(bar)overlap.render(&quot;1_ResourceforRetro/render3.html&quot;)&quot;&quot;&quot;使用Grid（）对象可以将python chart图并列编排，需要注意的是gird_left, right, height, width 参数的设置，由此引起的各chart图参数设置的调整，建议不要用百分比，这个容易引起显示错位下图被注释的代码基本达到了希望的效果&quot;&quot;&quot; 每一个图标的render语句会在当前脚本目录下生成一个该图标的html报告，如 - render(“1_ResourceforRetro/render3.html”)，此路径可自定义，默认是当前脚本路径，报告格式是html，不可改成其他类型。 获得了需要的图表报告后，接下来就是要将这些报告统一汇总在一张自定义的html文件中，下面是我上面demo图例中的自定义的html文件，不喜勿喷 @@@ 1234567891011121314151617181920212223242526272829303132333435363738394041424344import os, sysfrom Common_Functions_Consolidation import *#1. create new path for retrosepective report and retrospective report will locate on the sme path with the scripts# **********************************************************************************************************************************************************scriptPath = os.getcwd()reportFilePath = os.path.join(scriptPath, &quot;retrospective_Report.html&quot;)#2. Validate the folder &apos;&apos;htmlReport and see if it is being there already# **********************************************************************************************************************************************************print os.path.isdir(&quot;1_ResourceforRetro&quot;) # 文件夹名称是不分大小写的if os.path.isdir(&quot;1_ResourceforRetro&quot;) == False: print &quot;There is no folder of &apos;1_ResourceforRetro&apos; there, please ensure you got this folder first before running this script!&quot; sys.exit()#3. Define retrospective report form by python# **********************************************************************************************************************************************************reload(sys) # 这两句对字符一起可改变解析的字符编码风格sys.setdefaultencoding(&quot;utf-8&quot;) # 这两句对字符一起可改变解析的字符编码风格#3.1 define html header part of this report -# ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------reportTitle = &quot;测试线阶段工作汇总 - Apr. ~ Jul.&quot;pythonWriteHtml_to_File_Part1(reportFilePath, reportTitle)#3.2 define html body part which comes from &apos;htmlReport&apos; of this report -# --------------------------------------------------------------------------------------------------------------------------------------pythonWriteHtml_to_htmlReport(scriptPath, reportFilePath)# #3.3 define html body part which comes from &apos;htmlReport_1&apos; of this report -# # --------------------------------------------------------------------------------------------------------------------------------------# anotherProjectName = &quot;DCFM 告警单重构&quot;# addSecondProjectReport_Header(reportFilePath, anotherProjectName)# addSecondProjectReport_Body(scriptPath, reportFilePath)##4 define html ending part of this report -# --------------------------------------------------------------------------------------------------------------------------------------python_WriteHtml_to_File_Part2(reportFilePath) 这是上面代码中引用的包（Common_Functions_Consolidation）的相关函数实现-123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216def pythonWriteHtml_to_File_Part1(reportFilePath, reportTitle): # reportFilePath 是一个.html文件，这个文件通常由调用脚本生成 fo = open(reportFilePath, &quot;w+&quot;) # 打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。 # f.write(&quot;&lt;!DOCTYPE html&gt;\n&quot;) # f.write(&quot;&lt;h1&gt;alan&lt;/h1&gt;&quot;) # f.close() htmlText = &quot;&quot;&quot;&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;style type=&quot;text/css&quot;&gt; #header &#123; background-color:black; color:white; text-align:left; padding:5px; font-family:Gill Sans MT; font-size:22px &#125; #reportZone&#123; width:1550px; &lt;!--这个可以取消，不影响效果 --&gt; align:left; padding:5px; font-family:Gill Sans MT; font-size:12px &#125; .anotherProject&#123; background-color:black; color:white; text-align:left; padding:5px; font-family:Gill Sans MT; font-size:20px &#125; #footer &#123; background-color:black; color:white; font-family:Gill Sans MT; font-size:9px text-align:left; padding:2px; &#125; # for the animal text - @keyframes blink&#123; 0%&#123;opacity: 1;&#125; 50%&#123;opacity: 1;&#125; 50.01%&#123;opacity: 0;&#125; 100%&#123;opacity: 0;&#125; &#125; @-webkit-keyframes blink &#123; 0% &#123; opacity: 1; &#125; 50% &#123; opacity: 1; &#125; 50.01% &#123; opacity: 0; &#125; 100% &#123; opacity: 0; &#125; &#125; @-moz-keyframes blink &#123; 0% &#123; opacity: 1; &#125; 50% &#123; opacity: 1; &#125; 50.01% &#123; opacity: 0; &#125; 100% &#123; opacity: 0; &#125; &#125; @-ms-keyframes blink &#123; 0% &#123; opacity: 1; &#125; 50% &#123; opacity: 1; &#125; 50.01% &#123; opacity: 0; &#125; 100% &#123; opacity: 0; &#125; &#125; @-o-keyframes blink &#123; 0% &#123; opacity: 1; &#125; 50% &#123; opacity: 1; &#125; 50.01% &#123; opacity: 0; &#125; 100% &#123; opacity: 0; &#125; &#125; .blink&#123; animation: blink .85s linear ease-in; -webkit-animation: blink .75s ease-out infinite; -moz-animation: blink .55s ease-out infinite; -ms-animation: blink .65s ease-out infinite; -o-animation: blink .45s ease-out infinite; color: #F00; font-size:18px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;header&quot;&gt; &lt;h2&gt;&lt;hr/&gt; &quot;&quot;&quot; fo.write(htmlText) fo.close() fo = open(reportFilePath, &quot;a&quot;) # 打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。 fo.write(reportTitle) htmlText = &quot;&quot;&quot;&lt;hr/&gt;&lt;/h2&gt; &lt;/div&gt; &lt;div id=&quot;reportZone&quot;&gt; &lt;br&gt; &quot;&quot;&quot; fo.write(htmlText) fo.close()# ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------# Purpose - 定义html的尾部div 代码部分# Notice - 该文件夹和脚本是在同一目录下的# Date - 2018. 06.16# Author - Alan.yuan# ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------def python_WriteHtml_to_File_Part2(reportFilePath): # reportFilePath 是一个.html文件，这个文件通常由调用脚本生成 fo = open(reportFilePath, &apos;a&apos;) htmlText = &quot;&quot;&quot;&lt;/div&gt; &lt;div id=&quot;footer&quot;&gt; &lt;p&gt;&amp;nbsp Copyright © GDS_TestCenter@163.com. All rights reserved. This consolidation based on our test outputs, and the datum come from Jira and Testlink, it&apos;s real and valid. Consolidated here, just want you know more about our Test line, sincerely hope the effort we contributed is indeed to relief you.&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; &quot;&quot;&quot; fo.write(htmlText) fo.close()# ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------# Purpose - 检查文件夹是否存在，如果存在就移除里面所有的文件， 注意是移除里面所有的文件，不是文件夹；如果该文件夹不存在，则创建该文件夹# Notice - 该文件夹和脚本是在同一目录下的# Date - 2018. 06.16# Author - Alan.yuan# ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------def checkFolder_and_RemoveAllFilesIncluded(folderName):#该函数检当前脚本目录下是否有制定的folder，如果没有则创建该folder；如果有则进入该folder删除里面所有的文件（注意是文件，不是文件夹） import os, sys if os.path.exists(os.getcwd() + &quot;\\&quot; + folderName) == True: # folderName - 指的是第一个存储测试报告文件夹 “htmlReport” for file_Name in os.listdir(os.getcwd() + &quot;\\&quot; + folderName): # os.listdir(os.getcwd() + &quot;\htmlReport&quot;) - 该文件夹下包含的文件list path_File = os.path.join(os.getcwd() + &quot;\\&quot; + folderName, file_Name) if os.path.isfile(path_File): os.remove(path_File) else: os.makedirs(os.getcwd() + &quot;\\&quot; + folderName)# ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------# Purpose - 添加视图到body区，主要是&lt;image&gt; ... &lt;/image&gt; 部分代码# Notice - 该文件夹和脚本是在同一目录下的# Date - 2018. 06.16# Author - Alan.yuan# ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------def pythonWriteHtml_to_htmlReport(scriptPath, reportFilePath, listVal, listUnit): htmlTextB = &quot;&quot;&quot;&lt;iframe src=\&quot;&quot;&quot;&quot; htmlTextE = &quot;&quot;&quot;&quot; marginheight=&quot;2px&quot; marginwidth=&quot;2px&quot; width=&quot;1200&quot; height = &quot;500&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;&lt;br/&gt;&quot;&quot;&quot; i = 0 dirs = os.listdir(scriptPath + &quot;\\1_ResourceforRetro&quot;) for dir in dirs: if os.path.isfile(os.path.join(scriptPath + &quot;\\1_ResourceforRetro&quot;, dir)): fo = open(reportFilePath, &quot;a&quot;) fo.write(&quot;&lt;h3&gt; &gt;&gt;&gt;截止目前，统计有 &lt;span class=\&quot;blink\&quot; &gt;%s &lt;/span&gt;%s - &lt;/h3&gt;&quot;%(listVal[i], listUnit[i])) # listVal, listUnit元素个数必须和html 文件数相等，否则报溢出错误 # fo.write(&quot;&lt;span style=\&quot;border-color: green; border-width: 1px; border-style: solid; border-radius: 1px;\&quot;&gt;&quot;) fo.write(htmlTextB) fo.write(&quot;.\\1_ResourceforRetro\\&quot; + dir) fo.write(htmlTextE) fo.close() i += 1# ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------# Purpose - 添加第二个项目的html代码，主要是展示项目名称的&lt;div&gt; ... &lt;/idiv&gt; 部分代码# Notice - 该文件夹和脚本是在同一目录下的# Date - 2018. 06.16# Author - Alan.yuan# ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------def addSecondProjectReport_Header(reportFilePath, anotherProjectName): htmlHeard_2B = &quot;&quot;&quot;&lt;br/&gt;&lt;/div&gt; &lt;!--Adding new project / task --&gt; &lt;!--hr style = &quot;height:0px; border:none; border-top:10px solid #55555;&quot;/ --&gt; &lt;hr style=&quot;height:0px;border:none;border-top:10px groove skyblue;&quot; /&gt; &lt;div class = &quot;anotherProject&quot;&gt;&lt;b&gt;&quot;&quot;&quot; htmlHeard_2E = &quot;&quot;&quot;&lt;/b&gt;&lt;/div&gt;&lt;div&gt;&quot;&quot;&quot; fo = open(reportFilePath, &quot;a&quot;) fo.write(htmlHeard_2B) fo.write(anotherProjectName) fo.write(htmlHeard_2E) fo.close()# ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------# Purpose - 添加第二个项目的html代码，主要是图示的&lt;image&gt; ... &lt;/image&gt; 部分代码# Notice - 该文件夹和脚本是在同一目录下的# Date - 2018. 06.16# Author - Alan.yuan# ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------def addSecondProjectReport_Body(scriptPath, reportFilePath): html2B = &quot;&quot;&quot;&lt;iframe src=\&quot; &quot;&quot;&quot; html2E = &quot;&quot;&quot;&quot;marginheight=&quot;20px&quot; marginwidth=&quot;50px&quot; width=&quot;1450&quot; height = &quot;550&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;&lt;br/&gt;&quot;&quot;&quot; dirs = os.listdir(scriptPath + &quot;\htmlReport_1&quot;) for dir in dirs: if os.path.isfile(os.path.join(scriptPath + &quot;\htmlReport_1&quot;, dir)): fo = open(reportFilePath, &quot;a&quot;) fo.write(html2B) fo.write(&quot;.\htmlReport_1\\&quot; + dir) fo.write(html2E) fo.close()]]></content>
      <categories>
        <category>python自动化</category>
      </categories>
      <tags>
        <tag>Python开发</tag>
        <tag>python测试</tag>
        <tag>python echart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试管理修炼之搭建测试管理平台Testlink]]></title>
    <url>%2F2018%2F04%2F17%2F%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E4%BF%AE%E7%82%BC%E4%B9%8B%E6%90%AD%E5%BB%BA%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E5%B9%B3%E5%8F%B0Testlink%2F</url>
    <content type="text"><![CDATA[Preparation - Xampp官方资料 -https://bitnami.com/stack/xampp?utm_source=bitnami&amp;utm_medium=installer&amp;utm_campaign=XAMPP%2BInstallerXampp ： 建站集成软件包（apache，mysql，php， perl） 下载testlink 安装包 下载xampp 安装包 1. 安装指南 -如何安装设置，网上攻略有很多，这里提供一份网友的整理资料，很不错的 ~~一个有用的参考 2. 如何使用Testlink? 创建测试项目 创建测试计划 如有测试需求，可以将测试需求写进来做好这三步，回到Testlink的首页，你就会看到TestLink的全部目录了 创建测试用例集和测试用例了（根据测试需求、测试用例可以把每一个功能作为一个测试集，然后在每一个测试集中放测试用例） 把测试计划和测试用例关联起来 （进入TC，click 活动按钮，选择关联测试计划按钮即可关联 ） 创建测试版本 执行测试 如果有重复执行某一个case，可以创建新的版本，将这个case放进来，这样就可以记录每一次测试effort了 测试用例集（测试用例）要与测试计划，测试需求关联起来，并且只有构建了测试版本后，才可以开始测试。只有这样你的测试用例才算是一个完整地测试用例（也就是说一个用例包括了测试计划，需求，测试版本等完整信息），之后就可以分配测试给各个人员了。 3. Testlink中分析结果的图表乱码怎么办？ 如果发现图表显示乱码，可以这么解决 1、下载 tahoma.ttf 字体； 2、下载好后，我们将其放置到，testlink的安装目录的以下文件夹中：testlink/third_party/pchart/Fonts/接下来，修改配置文件config.inc.php：修改$tlCfg-&gt;charts_font_path = TL_ABS_PATH . “third_party/pchart/Fonts/tahoma.ttf”;为$tlCfg-&gt;charts_font_path = TL_ABS_PATH . “third_party/pchart/Fonts/SIMYOU.ttf”; 4. TestLink 如何突破文件上传大小限制 将这两个地方需要进行修改： 1.&gt; config.inc.php$tlCfg-&gt;repository_max_filesize = 15; //MB$tlCfg-&gt;import_file_max_size_bytes = ‘15409600$tlCfg-&gt;import_max_row = ‘15000000 2.&gt; php.iniupload_max_filesize=15Mpost_max_size=15M 5. Testlink 如何设置邮箱？TestLink目录下打开config.inc.php文件修改以下部分，红色背景为填写部分，后面#符号后面为注释，把下面序号后面内容整行直接放到代码中不影响使用（更换真实邮箱地址）。 （1）$g_smtp_host = ‘smtp.163.com’; # 邮件服务器地址，此处选择163邮箱 （2）$g_tl_admin_email = &#39;test@163.com‘; # 问题错误通知邮箱 （3）$g_from_email = ‘test@163.com‘; # 收到收件看到的发送人邮箱地址 （4）$g_return_path_email = &#39;test@163.com‘; # 收件人回复的邮箱地址 （5）$g_phpMailer_method = PHPMAILER_METHOD_SMTP更改为$g_phpMailer_method =SMTP_SEND （6）在步骤（5）代码上一行增加define (“SMTP_SEND”,2); （7）$g_smtp_username = &#39;test@163.com‘; # 此处填写你的163信箱地址 （8）$g_smtp_password = ‘test123546’; # 此处填写163的客户端授权密码，注意一定不是邮箱密码 （9）$g_smtp_connection_mode = ‘ssl’; （10）$g_smtp_port = 994;我申请了一个XXX_testcenter@163.com的邮箱 (password:xxxxxx) / 授权码是：嘻嘻嘻嘻嘻保存退出，设置完毕，可使用TestLink密码找回功能尝试是否成功。 Testlink使用小结 使用testlink要结合实际测试流程，这样使用起来才能得心应手，通常我们可以按照如下步骤来使用该系统： 测试项目-&gt; 测试计划 （使其活动）-&gt; 测试需求 -&gt; 测试用例 -&gt; 测试版本 -&gt; 测试分配 -&gt; 测试执行 -&gt; 测试统计 要执行测试必须要有测试计划和测试版本（也就是计划和测试构建）而计划必须和TC关联的，因此当执行某个TC时，一定是某个计划的某个版本（构建）下的某个TC；测试计划关联测试用例和测试构建（版本）；另外，如果有测试平台的话，在将测试用例和测试计划关联时也要将测试平台关联进去。这样在执行测试时就可以选择在某个平台下的测试用例了。（设置好后，在执行测试时，在右边的设置/Filter栏位可以选择是执行哪个平台下的测试用例了。） 另外，测试用例和测试需求理论上也需要关联，同测试用例类似，先建立一个“需求规格”，然后在需求规格下面新建具体需求，然后再将需求关联到具体的TC，如果只有需求规格，下面没有具体需求，那么无法将TC和需求关联起来。想想也是这个道理，每具体需求关联什么呀？ 在测试结果中，可以在“测试用例分派概览”和“测试结果矩阵”报表中查看测试执行小图标来查看该用例执行的次数和每次的工时。由此可以统计出某一计划下所有执行的完整工时。其他报表点击用户进入用户视图，也可以找到执行图标来查看，但没有这两个报表来得直接；其他视图展示出来的工时，通常只是最近执行的工时，不可用这此工时来代替完整工时统计。]]></content>
      <categories>
        <category>测试管理</category>
        <category>testlink</category>
      </categories>
      <tags>
        <tag>测试管理</tag>
        <tag>testlink</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python在Excel中的应用]]></title>
    <url>%2F2017%2F09%2F22%2FPython%E5%9C%A8Excel%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[这是之前做的一个python在excel中使用的例子，个人感觉还是蛮有意思的，今天拿出来分享给大家，其中也许有你感兴趣的地方。 代码执行的结果如下 -查看结果 代码实现如下 -123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252from selenium import webdriverfrom selenium.common.exceptions import NoSuchElementExceptionimport time, osfrom selenium.webdriver.common.keys import Keysfrom selenium.webdriver.support.wait import WebDriverWaitfrom Python_TestReport_Excel_Template import *from win32com.client import Dispatch, constantsimport win32com.clientimport os, timedef Preprocess_Environment_One_to_Five(): # return &apos;startTime&apos; - Don&apos;t change this return variable name because it will be used in report format function. os.system(&apos;taskkill /fi &quot;imagename eq exce*&quot; /f&apos;) os.system(&apos;taskkill /IM IEDriverSe* /f&apos;) os.system(&apos;taskkill /fi &quot;imagename eq iexplo*&quot; /f&apos;) initialTime = datetime.datetime.now() return initialTimestartTime = Preprocess_Environment_One_to_Five()# Get current script path and folderdef CollectInfo_for_TestReport(): # Get parameters of script path and report path getRootFolder = os.path.abspath(&quot;.&quot;) # get whole folder path which saved all current scripts. # get current Date and script Name getCurrentDate = time.strftime(&quot;%Y-%m-%d&quot;, time.localtime()) suffixScriptName = os.path.basename(__file__) pureScriptName = suffixScriptName.split(&apos;.&apos;, 1)[0] reportPath = os.path.join(getRootFolder, &quot;Test_Reports&quot;, getCurrentDate, pureScriptName) return pureScriptName, reportPathpureScriptName, reportPath = CollectInfo_for_TestReport() # 这两个变量名不要更改名字，因为后面需要这两个变量作为参数值，因为名称完全一样，所以这里的变量名不要随意更改。def Create_Report_and_Initialize_Headers(reportPath): # Create Report Path and report file and rename the default sheet name to Runtime_1 reportFile = os.path.join(reportPath, &quot;Excution_Result.xlsx&quot;) headersList = (&apos;No&apos;, &apos;Checkpoints&apos;, &apos;Expectation Result&apos;, &apos;Real Result&apos;, &apos;Final Status&apos;, &apos;Screen Shot&apos;, &apos;Other Reference&apos;) # Header 请按此顺序定义column, 后续程序根据此column来展开脚本 print &quot;&gt;&gt;&gt; Test report will be created and located here - &quot;, reportFile if os.path.exists(reportPath): # 这里的参数不能为具体的文件名路径，只能是Folder的path pass print &quot;&gt;&gt;&gt; Report path was created already, please check the test report file and see if it also be created&quot; else: os.makedirs(reportPath) # 一次性创建多级目录，而mkdir一次只能创建一级目录, makedirs 和 mkdir只能创建文件夹，并不能穿件文件本身; 另外，makedirs不能覆盖存在的路径。 # fo = open(reportFile, &apos;w+&apos;) # fo.close() # 创建的Excel.xlsx文件没法打开，由于格式不兼容的问题 if os.path.exists(reportFile): print &quot;&gt;&gt;&gt; Test report already created and here need to do is to add one more new sheet and initialized &quot; xlApp = Dispatch(&quot;Excel.Application&quot;) # 连接 excel 对象 xlOpenWorkBook = xlApp.Workbooks.Open(reportFile) sheetCount = xlOpenWorkBook.Worksheets.Count addedSheetName = &quot;Runtime_&quot; + str(sheetCount + 1) xlApp.Worksheets.Add().Name = addedSheetName for i in range(0, len(headersList)): xlOpenWorkBook.Worksheets(addedSheetName).Cells(1, i+1).value = headersList[i] xlOpenWorkBook.Save() # 此处用Save()保存已打开的excel文件，无论之前的excel是否开启，都可以执行代码；不要用SaveAs(reportFile)会出现保存的文件已开启的提示框，而Python对windows下的excel提示框，不好操作 xlApp.Quit() else: xlApp = Dispatch(&quot;Excel.Application&quot;) # 连接 excel 对象 xlBook = xlApp.Workbooks.Add() # 新建一个excel文件 xlBook.Worksheets[0].name = &quot;Runtime_1&quot; # 默认情况下只创建包含一个名为 ‘sheet1’ 的表单 for i in range(0, len(headersList)): xlBook.Worksheets[0].Cells(1, i+1).value = headersList[i] # initialize header base on the headerlist parameter xlBook.SaveAs(reportFile) xlApp.Quit() print &quot;&gt;&gt;&gt; Test Report was just created and initializated headers&quot; return reportFile # define Report Headers -# headerList = (&apos;No&apos;, &apos;Checkpoints&apos;, &apos;Expectation Result&apos;, &apos;Real Result&apos;, &apos;Final Status&apos;, &apos;Screen Shot&apos;, &apos;Other Reference&apos;)# reportFile = Create_Report_and_Initialize_Headers(reportPath, *headerList)reportFile = Create_Report_and_Initialize_Headers(reportPath)class Add_Checkpoints: # os.system(&apos;taskkill /fi &quot;imagename eq exce*&quot; /f&apos;) def byPassed(self, reportFile, checkPointStatement): xlApp = Dispatch(&quot;Excel.Application&quot;) xlOpenWorkBook = xlApp.Workbooks.Open(reportFile) sheetCount = xlOpenWorkBook.Worksheets.Count; objSheetName = &quot;Runtime_&quot; + str(sheetCount) #获得sheet name 主要是为了从sheet名称上来打开指定的sheet，当然也可以用sheets[0]来表示，因为在脚本中创建的sheet都是位于第一个sheet的位置 rowCount = xlOpenWorkBook.Worksheets(objSheetName).UsedRange.Rows.Count objSheet = xlOpenWorkBook.Worksheets(objSheetName) # Notice 下面的写法同样有效。 # objSheet = xlApp.Worksheets(objSheetName) objSheet.Cells(rowCount + 1, 1).Value = rowCount objSheet.Cells(rowCount + 1, 2).Value = checkPointStatement objSheet.Cells(rowCount + 1, 3).Value = &quot;The checkpoint of &apos;&quot; + checkPointStatement + &quot;&apos; should be able to go smoothly with this pre-condition&quot; objSheet.Cells(rowCount + 1, 4).Value = &quot;Yeah ... ! Scripts really detected this checkpoint&apos;&quot; + checkPointStatement + &quot;&apos; at the specified condition&quot; objSheet.Cells(rowCount + 1, 5).Value = &quot;Pass&quot; xlOpenWorkBook.Save() # Notice - Save 和Save()的区别，一个是单纯的宏命令动作，一个是方法，方法里面包含了对save这个动作的后续处理。所以这里如果只用Save则会弹出保存对话框，不如Save()方便直接。 xlApp.Quit() def byFailure(self, reportFile, checkPointStatement): # os.system(&quot;taskkill /F /IM Exce*&quot;) xlApp = Dispatch(&quot;Excel.Application&quot;) xlOpenWorkBook = xlApp.Workbooks.Open(reportFile) sheetCount = xlOpenWorkBook.Worksheets.Count; objSheetName = &quot;Runtime_&quot; + str(sheetCount) # 获得sheet name 主要是为了从sheet名称上来打开指定的sheet，当然也可以用sheets[0]来表示，因为在脚本中创建的sheet都是位于第一个sheet的位置 rowCount = xlOpenWorkBook.Worksheets(objSheetName).UsedRange.Rows.Count objSheet = xlApp.Worksheets(objSheetName) objSheet.Cells(rowCount + 1, 1).Value = rowCount objSheet.Cells(rowCount + 1, 2).Value = checkPointStatement objSheet.Cells(rowCount + 1, 3).value = &quot;The checkpoint of &apos;&quot; + checkPointStatement + &quot;&apos; should be able to go smoothly with this pre-condition&quot; # please use plus symbol instead comma to combine varaible and string here objSheet.Cells(rowCount + 1, 4).Value = &quot;Unfortunately ... ! Scripts didn&apos;t detect this checkpoint&apos;&quot;+ checkPointStatement +&quot;&apos; at the specified conditions&quot; # 连接checkPointStatement变量，不能用comma,只能用plus/ + 号 objSheet.Cells(rowCount + 1, 5).Value = &quot;Failure&quot; xlOpenWorkBook.Save() xlApp.Quit()newClass = Add_Checkpoints() # 必须要实例化类才能使用，这是常识。# if &apos;xiaole&apos; in &quot;alan love xiaole&quot;:# newAClass.byPassed(&quot;Check string - &apos;alan&apos; and see if it&apos;s existing in &apos;alan love xiaole&apos; string&quot;)# else:# newAClass.byFailure(&quot;Check string - &apos;alan&apos; and see if it&apos;s existing in &apos;alan love xiaole&apos; string&quot;)## time.sleep(15)for i in range(0, 1): if u&quot;张寒冰&quot; in u&quot;这段文字中包含张寒冰三个字吗？&quot;: newClass.byPassed(reportFile, u&quot;search &apos;张寒冰&apos; and see if it&apos;s searched in the gaven string&quot;) else: newClass.byFailure(reportFile, u&quot;search &apos;张寒冰&apos; and see if it&apos;s searched in the gaven string&quot;) if u&quot;张寒冰&quot; in u&quot;这段文字中能找出张汉滨吗？&quot;: newClass.byPassed(reportFile, u&quot;search &apos;张寒冰&apos; and see if it&apos;s searched in the gaven string&quot;) else: newClass.byFailure(reportFile, u&quot;search &apos;张寒冰&apos; and see if it&apos;s searched in the gaven string&quot;) if &quot;morgan&quot; in &quot;www.morgan.com.\mainpage.index\Finace.us.123.pageo&quot;: newClass.byPassed(reportFile, &quot;Check Mogstandley and see if it&apos;s in this string &apos;www.morgan.com&apos;&quot;); else: newClass.byFailure(reportFile, &quot;Check Mogstandley and see if it&apos;s in this string &apos;www.morgan.com&apos;&quot;) if &quot;Shanghai Financial&quot; in &quot;List all the records which search by Sublege for Baidu, and Tencent&quot;: newClass.byPassed(reportFile, &quot;Check the string of &apos;subledge&apos; and see if it will be show at the specified page which searched by definited for Baidu and Tencent&quot;) else: newClass.byFailure(reportFile, &quot;Check the string of &apos;subledge&apos; and see if it will be show at the specified page which searched by definited for Baidu and Tencent&quot;) if &quot;Shanghai&quot; in &quot;www.morgan.com.mainpage.index.Shanghai Finanial Center&quot;: newClass.byPassed(reportFile, &quot;Check Mogstandley and see if it&apos;s in this string &apos;www.morgan.com.\mainpage.index\Finace.us.233.pageContext&apos;&quot;) else: newClass.byFailure(reportFile, &quot;Check Mogstandley and see if it&apos;s in this string &apos;www.morgan.com.\mainpage.index\Finace.us.233.pageContext&apos;&quot;) if &quot;Xiaole&quot; in &quot;www.morgan.com\second1-2-3\content.list-us.sgn-Xiaole&quot;: newClass.byPassed(reportFile, &quot;Check the string of &apos;Xiaole&apos; and see if it will be show at the specified page content &apos;www.morgan.com\second1-2-3\content.list-us.sgn-Xiaole&apos;&quot;) else: newClass.byFailure(reportFile, &quot;Check the string of &apos;Xiaole&apos; and see if it will be show at the specified page content &apos;www.morgan.com\second1-2-3\content.list-us.sgn-Xiaole&apos;&quot;) if &quot;LuckyLee&quot; in u&quot;请将每天的作业按时做完，然后也完成我的家庭作业和课外练习题，睡觉前送我检查并签字，切记！send to LucyLee&quot;: newClass.byPassed(reportFile, u&quot;检查乐乐的作业情况是否按时完成！并记得每天签字 - Yuan, Jun-tao&quot;) else: newClass.byFailure(reportFile, u&quot;检查乐乐的作业情况是否按时完成！并记得每天签字 - Yuan, Jun-tao&quot;)# openedWorkBook = xlApp.Workbooks.Open(&quot;C:\\temp\\alan123.xlsx&quot;)# print openedWorkBook.Worksheets.Count# print openedWorkBook.Worksheets[0].name; openedWorkBook.Worksheets.Item(1).name # 两种写法均可获得sheet name# print openedWorkBook.Worksheets[0].UsedRange.Rows.Count# print openedWorkBook.Worksheets[0].UsedRange.Columns.Count#`def Format_Report(reportFile, scriptAuthor, startTime, getPureScriptName = pureScriptName): if os.path.exists(reportFile): # Step One - Create Excel.Application Object and Open an existing file and enter the specified sheet xlApp = Dispatch(&quot;Excel.Application&quot;) xlOpenWorkBook = xlApp.Workbooks.Open(reportFile) sheetCount = xlOpenWorkBook.Worksheets.Count; objSheetName = &quot;Runtime_&quot; + str(sheetCount) # 获得sheet name 主要是为了从sheet名称上来打开指定的sheet，当然也可以用sheets[0]来表示，因为在脚本中创建的sheet都是位于第一个sheet的位置 xlOpenSheet = xlOpenWorkBook.Worksheets(objSheetName) #Step Two - Format specified sheet Font.Size and Font Bold xlOpenSheet.UsedRange.Font.Name = &quot;Gill Sans MT&quot; xlOpenSheet.UsedRange.Font.Size = 10 xlOpenSheet.UsedRange.Rows(1).Font.Size = 12 # Rows(1) 和 Row[1] 表示的意义不一样，前者代表第一行，后者表示第二行。这就是下标使用的作用 xlOpenSheet.UsedRange.Rows(1).Font.Bold = True # Notice this expression and it&apos;s equal the usage below in Bold and Italic # Add border and add two more top row for Report Title xlOpenSheet.UsedRange.Borders.LineStyle = 1 # xlOpenSheet.UsedRange.Rows(1).Borders.LineStyle = -4119 xlOpenSheet.Rows[0].Insert() xlOpenSheet.Rows[0].RowHeight = 5 # 设置行高; ColumnWidth 用于设置列宽 xlOpenSheet.Rows[0].Insert() xlOpenSheet.Rows[0].RowHeight = 30 xlOpenSheet.Range(&quot;A1:G1&quot;).Borders(4).LineStyle = 1 xlOpenSheet.Range(&quot;A1:G1&quot;).Borders(4).Weight = 3 # may be 4, 3, 1 not others xlOpenSheet.Range(&quot;A1:G1&quot;).Merge() # merge cells for report title text xlOpenSheet.Cells(1, 1).Value = &quot;Execution Result for Scripts - &quot; + pureScriptName # define the report title # xlOpenSheet.Range(&quot;A1&quot;).Font.ColorIndex = 5 # or 41 for setting blue and light blue value xlOpenSheet.Cells(1, 1).Font.Name = &quot;Gill Sans MT&quot;; xlOpenSheet.Cells(1, 1).Font.Size = 15; xlOpenSheet.Cells(1, 1).Font.Bold = True # How to implement AutoFit? # xlOpenSheet.UsedRange.Columns.AutoFit() xlOpenSheet.UsedRange.EntireColumn.AutoFit() xlOpenSheet.UsedRange.HorizontalAlignment = 2 # maybe these value - Alignment, 1=auto | Alignment, 2=left | Alignment, 3=centre |Alignment, 4=right | | xlOpenSheet.UsedRange.VerticalAlignment = 2 # may be these initialization - Alignment, 1=top | Alignment, 2=middle | Alignment, 3=bottom | # Set report tile alignment and make it align on bottom xlOpenSheet.UsedRange.Rows(1).VerticalAlignment = 3 # Format Result Color and make the failure record highlighted by Red font and then statistic the checkpoints result rowsCount = xlOpenSheet.UsedRange.Rows.Count; passQty = 0; failQty = 0 for i in range(4, rowsCount + 1): if &quot;Pass&quot; == xlOpenSheet.Cells(i, &quot;E&quot;).value: # Notice here - .value is quitely equal .Value passQty += 1 pass else: print &quot;&gt;&gt;&gt; A failure checkpoint found&quot; xlOpenSheet.UsedRange.Rows(i).Font.ColorIndex = 46 ; xlOpenSheet.UsedRange.Rows(i).Font.FontStyle = &quot;Italic&quot;; xlOpenSheet.UsedRange.Rows(i).Font.Bold = True # ColorIndex value can refer to the &quot;https://zhidao.baidu.com/question/90240687.html&quot;. xlOpenSheet.UsedRange.Cells(i, &quot;E&quot;).Font.ColorIndex = 6 # set font to red # xlOpenSheet.UsedRange.Rows(i).Interior.ColorIndex = 3 # set the selected block back graound color to red xlOpenSheet.UsedRange.Cells(i, &quot;E&quot;).Interior.ColorIndex = 3 # set the cell back ground color not for Font color failQty += 1 # 增加最左边一列，以利排版美观 xlOpenSheet.Range(&quot;A:A&quot;).Insert() # Notice - this expression is actually equal with aove one on Insert() xlOpenSheet.Range(&quot;A1:A&quot; + str(rowsCount + 7)).Borders(2).LineStyle = 1; xlOpenSheet.Range(&quot;A1:A&quot; + str(rowsCount + 13)).Borders(2).Weight = 4 # 格式化首列的最右边的实线边框 # xlOpenSheet.Cells(1, 1).Border(3).LineStyle = 1; xlOpenSheet.Cells(1, 1).Borders(3).Weight = 4; xlOpenSheet.Columns(1).ColumnWidth = 12 # Cells对象后面没有Borders属性，只能用Range来调用Border属性 xlOpenSheet.Range(&quot;A1&quot;).Borders(4).LineStyle = 1; xlOpenSheet.Range(&quot;A1:A1&quot;).Borders(4).Weight = 3; xlOpenSheet.Columns(&quot;A&quot;).ColumnWidth = 4 # 格式化单元格A1的宽度和下划线, 注意这里Range(&quot;A1&quot;)不能写成Cells(&quot;A1&quot;), 否则报错 # 去掉视图的网格线以及标题栏和标尺等属性 xlApp.ActiveWindow.DisplayGridlines = False xlApp.ActiveWindow.DisplayHeadings = False xlApp.ActiveWindow.DisplayFormulas = False xlApp.ActiveWindow.DisplayWhitespace = False xlApp.ActiveWindow.DisplayRuler = False # Extract and calculate Key words information xlOpenSheet.Cells(rowsCount + 3, 2).Value = &quot;Key Information Extract -&quot;; xlOpenSheet.Cells(rowsCount + 3, 2).Font.Name = &quot;Gill Sans MT&quot;; xlOpenSheet.Cells(rowsCount + 3, 2).Font.FontStyle = &quot;Bold&quot; ; xlOpenSheet.Range(&quot;B&quot; + str(rowsCount + 3) + &quot;:C&quot; + str(rowsCount + 3)).Borders(4).LineStyle = 1 # 注意此处Bold的设置和前面同样效果的设置区别 projectName = reportFile.split(&quot;\Test_Reports&quot;)[0].split(&quot;\\&quot;)[len(reportFile.split(&quot;\Test_Reports&quot;)[0].split(&quot;\\&quot;)) - 1] currentTime = datetime.datetime.now(); differ = (currentTime - startTime).seconds; h = differ / 3600; m = (differ % 3600) / 60; s = (differ % 3600) % 60 # the calculation difference between operate / and //, they would get the same value when the calculate under the all intgers, or difference durationTime = str(h)+&apos;:&apos;+str(m)+&apos;:&apos;+str(s) # Merge Rows and Definition the key words informations - xlOpenSheet.Range(&quot;B&quot; + str(rowsCount + 4) + &quot;:H&quot; + str(rowsCount + 12)).Merge() xlOpenSheet.Cells(rowsCount + 4, &quot;B&quot;).Value = &quot; Script Name: &quot; + getPureScriptName + &quot; \n Project Name: &quot; + projectName + &quot; \n Duration (Hr:Min:Sec) - &quot; + durationTime + &quot; \n Passed Checkpoints: &quot; + str(passQty) + &quot; \n Failed Checkpoints: &quot; + str(failQty) + &quot; \n Automated Architecture Author: Alan.Yuan \n Script Executor/Designer: &quot; + scriptAuthor xlOpenSheet.UsedRange.Rows(rowsCount + 4).Font.Name = &quot;Gill Sans MT&quot;; xlOpenSheet.UsedRange.Rows(rowsCount + 4).Font.Size = 10 ; #xlOpenSheet.Range(&quot;B&quot; + str(rowsCount + 4) + &quot;:H&quot; + str(rowsCount + 12)).Font.FontStyle = &quot;Italic&quot;; # xlOpenSheet.UsedRange.Rows(rowsCount + 4).VerticalAlignment = 1 # Notice - Range() 和 UsedRange.Rows()的用法，这里不可用Rows()取代UsedRange.Rows()，否则报错 # rowCount = xlOpenWorkBook.Worksheets(objSheetName).UsedRange.Rows.Count xlOpenWorkBook.Save() print &quot;So far, there are&quot;, xlOpenSheet.UsedRange.Rows.Count, &quot;rows are available&quot; # comma 连接的是任何数据类型，并且会自动加空格；plus连接的是同类型数据，不会自动加空格，这既是，和 + 连接符的区别 print &quot;So far, there are&quot;, xlOpenSheet.UsedRange.Columns.Count, &quot;Columns are available&quot; xlApp.Quit()# scriptAuthor=u&quot;Lello_Lucky&quot;Format_Report(reportFile, &quot;Lello_Yuan&quot;, startTime)]]></content>
      <categories>
        <category>python自动化</category>
        <category>excel</category>
      </categories>
      <tags>
        <tag>python自动化</tag>
        <tag>excel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试管理修炼之如何成为一名优秀的测试总监]]></title>
    <url>%2F2017%2F06%2F19%2F%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E4%BF%AE%E7%82%BC%E4%B9%8B%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E4%B8%80%E5%90%8D%E4%BC%98%E7%A7%80%E7%9A%84%E6%B5%8B%E8%AF%95%E6%80%BB%E7%9B%91%2F</url>
    <content type="text"><![CDATA[俗话说得好，不经历风雨怎么见彩虹，不被坑的领导不是真正的领导。测试工作是一门跨学科的工作，想成为一名优秀的测试管理者，除了具备跨学科的综合技能外，在制定工作流程和规章制度中一定要遵循可实施，可监督，可统计，可归纳等基本要素，如何做到这一点呢，我认为不防从如下方面多多思考和历练。首先测试的类别繁多，平常所说的功能测试，性能测试，压力测试，冒烟测试，平台测试（SDK、Web，GM工具等等，种类繁多。作为一个测试管理者，可根据团队实际（如人员多少，团队整体技术力量，测试环境等），合理的划分测试类别和内容。把功能和关联性强的接口日志等放在测试组中测试，把关联性较弱的如性能，平台兼容性，SDK，单元测试等放在平台组中去测试。这样可以充分发挥团队的效率。一旦测试任务和测试资源确定后，可以通过如下的步骤来具体实施。 这里我把质量管理的工作拆分为如下九个过程来具体展开 - 软件质量管理的九个方面 1. 需求管理过程 -我认为测试人员至少要关注这些方面 ○ 评估需求的合理性 - 不是100%的接受需求描述，哪些不合理的需求，哪些值得优化的地方，需要及时的指出 ○ 思考测试难度和测试周期 - 梳理需求时要尽量考虑每个功能点的难易度和评估所需时间，对于那些不能测试，或者测试难度很大的地方要及时提出，并和相关开发人员沟通解决方案，尽量做到全面，准确的评估。有利于后续的计划安排。 ○ 思考关联度 - 是不是全新的功能需求，是否与已有的功能有关联，是否需要测试性关联的功能点。这也是在需求管理过程中值得关注的地方。 2. 计划管理过程这个过程中核心就是时间，每个环节的时间预估越准确，则项目的可控性越高，反之，则会导致各种不可预估的延期。作为测试质量管理者，可从以下方面来考量计划的制定 3. 任务分配过程从这几方面来考虑 4. 执行管理过程关注和监督执行情况，了解动态信息，发现可能导致结果达不到的苗头要及时作出调整，或增加人手，或调整任务，或修改预期方案等等。 5. 反馈管理过程任务信息孤岛的出现会给项目带来潜在的风险，所以不要关起门来做测试，要及时的沟通，协调，不仅要知道自己在干什么，也要知道别人在干什么，也要让别人知道你在干什么。 6. bug管理过程Bug管理最常见，也最容易被大家忽视。在这个过程中，我们需要关注八个方面，见下图： 其中bug数据分析，可以帮助我们清楚地了解，哪些模块，哪些开发人员容易出错，推进TDD模式，也许可以从此展开 7. 版本管理过程1234○ 版本内容 -该进版本的内容必须进全，不该进版本的内容必须不进。这句看似废话的描述，实则是各种血泪史的控诉。版本中无论是少内容还是多内容，都会导致bug的出现。发版本前，多花一些时间，检查和控制好版本内容，则完全可以避免这一类问题的出现，做到防患于未然远比出了问题再修改要好的多。另一点则是，任何内容的提交都需要经过测试，这条也是蹚了无数的雷才形成的流程。任何自认为代码没问题就提交而未经过测试的，往往是频繁出bug的地方。○ 版本时间 - 为什么版本时间这么重要？晚一天发布不行吗？真实的答案是不行。任何跨天的延期发布都可能导致游戏内众多的活动内容调整，官网内容调整，更不用说昂贵的广告费用打了水漂。所以版本时间一定要控制好，尽量提前预估好时间，留出充足的时间来准备发布。○ 其他 - 除了上述2点需要注意的，版本管理还需要注意兼容、版本纪录和版本发布后的线上监控等琐碎问题。 8. 文档管理过程文档管理重要程度看似鸡肋，而往往则是这个鸡肋能关键时刻救你一命。一个项目周期越长，如果没有详细的文档纪录，还有项目人员的变动，可能到项目后期都没有一个人能清楚某些规则。对于测试也是一样，需要做哪些文档管理呢？见下图： 1还是那句话，传承做不好的项目不是好项目。 9. 部门沟通协调管理过程在现在项目过程中，协调部门间的资源越发重要，这基于两点现实： ○ 任何个体都无法保证项目质量。 ○ 资源具有稀缺性，需要协调一切可利用的资源为己所用。 怎么做？一句话，沟通，不断沟通，玩命沟通。 踩过了无数的坑，才能明白做好项目的质量保证工作并非易事。趟了无数的雷，才能将一条条血泪总结成经验流程。 参考资料 -http://www.51testing.com/html/12/n-3702192812.html]]></content>
      <categories>
        <category>测试管理</category>
      </categories>
      <tags>
        <tag>测试管理</tag>
        <tag>测试总监</tag>
        <tag>软件测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[How to build up a personality blog ?]]></title>
    <url>%2F2016%2F09%2F22%2Fhello-world%2F</url>
    <content type="text"><![CDATA[记录是个良好的习惯，及时地将工作和学习中的知识点记录下来，不仅能加深记忆还能帮助理解，俗话说得好，好记性不如烂笔头，不爱笔记三天学习两天忘记。现实中人们记录的方式有很多，最常用的莫过于博客了，当然现在提供博客服务的网站有很多，但大多千篇一律，不够个性化，为了不受限于各大平台，搭建个人定制化的博客很有必要，这里给大家介绍一种当下流行的，比较有逼格的个性化博客定制方案Hexo+Github Pages，当然不在乎形式的童鞋请略过。 Quick Start With A Personal Blog Precondition 什么是 Hexo？ Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 安装前提 安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序： • Node.js • Git 备注下， Node.js 是一个让 JavaScript 运行在服务端的开发平台，它让 JavaScript 成为与PHP、Python、Perl、Ruby 等服务端语言平起平坐的脚本语言, 它也是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。 因为hexo是一款基于Node.js的静态博客框架，所以在使用hexo搭建博客站点时，必须要先安装Node.js进行解析，而Git提供了分布式版本管理的实现，包括生成，启动服务，部署等操作，基于node.js的hexo博客是需要类似于Git的工具来实现网站的发布和管理的，当然DOS-Mode下也是可以的。 完成上面步骤后，本地选择一个文件夹作为blog根目录，然后启动git cmd, Dos-Mode 或 git bash（多数用git bash）执行如下hexo命令，创建本地博客框架123$ cd D:\myblog_repository # 假定你的blog仓库为 myblog_repository$ hexo init # 初始化blog site$ nmp install XXXXpackages # 根据上一步的提示安装相应的依赖包 上面的安装步骤下来，如果没有报错，你的blog环境配置就完成了。接下来只需运行几个命令就可以生成默认静态页面了1234Hexo clean /hexo cHexo generate /hexo gHexo deploy /hexo dHexo server /hexo s 在本地浏览器下输入localhost：4000,回车后看看能不能看到hello world页面，如果能看到，恭喜你！博客本地架构已生效，可以开始专注写博客了。 Basic Hexo SyntaxCreate a new page/post1234常用几种写法 -$ hexo new "My New Post"$ hexo new page "tags"$ hexo new post "categories" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 小结一下： Hexo就是一个Nodejs的产品，用它可以方便快捷的生成静态页面，而github的pages又可以为静态页面提供展示和域名空间服务，并且能很好地支持Markdown文法，这就为个性化定制blog提供了绝好的机会。blog的精神在于内容，高效的写作博文还需要掌握一些基本技能，如Yaml文法，Markdown基本语法以及页面格式和编排的Html，CSS文法等等，这些我将在后续的博文中陆续介绍。]]></content>
  </entry>
  <entry>
    <title><![CDATA[测试管理修炼之测试管理体系建设]]></title>
    <url>%2F2016%2F03%2F20%2F%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E4%BF%AE%E7%82%BC%E4%B9%8B%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E4%BD%93%E7%B3%BB%E5%BB%BA%E8%AE%BE%2F</url>
    <content type="text"><![CDATA[1. 测试的价值1应该体现在- 测试工作或技术对项目流程的渗透，以及在整体产品生命周期中主动质量控制以及对生产流程的改进和完善应该是测试终极价值的体现，这并非是一两个测试技术高手，或引入几个测试技术能解决的事情。从整个产品的链条来看，测试和其他环节一样重要，是整个产品不可或缺的关键节点。 2. 软件开发生命周期大致分为 - 需求计划（产品部门）–&gt; 概要设计（研发部门、产品部门）–&gt;详细设计（研发部门）–&gt;编码实现/Coding（研发部门）–&gt; 测试(测试部门) –&gt; 验收（产品部门） 该过程是产品生命周期的必然体现。无论采取哪种开发模式(瀑布式，敏捷模式)都应该遵行该过程，开发模式的不同主要体现在开发效率上，而并非要违反产品的生命周期。 3. 测试体现建设的整体思路测试管理体系是一个系统工程，要建设测试管理体系要从构成该系统的过程加以识别和管理，以实现设定的系统目标，同时要确保各个过程协同作用相互促进。从而使它们的总体作用大于各个作用之和。 建设测试体现的宗旨就是让测试渗透到软件生命周期的各个环境，从而更早的发现和排除缺陷。 测试体系的建设可以从如下几个方面/过程来考量： 测试规划（Test Strategy）- 确定各测试阶段的目标和策略，明确各测试阶段的活动安排，时间节点和资源配置（如人员安排，设备安排，技术及其他安排等）以及跟踪和控制测试过程的活动等内容；该过程输出测试计划（Test Plan）。如需求阶段要完成验收计划（UAT 计划），概要设计阶段要完成系统测试计划，详细设计阶段要完成集成测试计划（SIT 计划），编码阶段要完成单元测试计划（Unit Test 计划）任何对计划的修改都要提交评审组评审（评审组通常由项目的各个相关方组成，如产品人员，开发人员，测试以及QA人员等） 测试设计 - 即根据测试计划设计测试方案，该过程输出测试用例（Test Case），此过程与软件开发活动同步进行，其结果可作为各阶段测试计划的附件进行提交审核。 测试实施 - 就是根据测试用例来执行测试，并对结果进行对比，记录，缺陷跟踪和管理等活动，最终得到测试报告（Test Report） 配置管理 - 是软件管理的子集，作用于测试的各个阶段（即需求阶段，概要阶段，详细设计阶段，编码阶段，验收阶段等）， 管理对象包括测试计划，测试用例，测试版 本，测试结果，测试工具以及环境等内容。 资源管理 - 包括对人力资源和工作场所，以及相关设施和技术支持的管理。如果有专用实验室，还有其他管理等内容覆盖。 测试管理 - 即采取使用的方法对上述过程及结果进行监视，并在适用时进行测量，以保证过程的有效性，如果发现过程没有达到预期的效果，还可进行适当的调整或纠正。 以上六个过程可作为建设软件管理体系的实施步骤，首先要确定软件测试所需的过程和应用（根据公司实际情况从六大步骤中选择确定）；然后就是要确定这些过程的顺序和相互作用；确定这些过程所需的准则和方法，一般应制定这些过程形成文件的程序，以及监视，测量和控制的标准和方法（这一步可参考TMMI标准来进行制定）。从以上六个过程中可以看出，测试阶段要产出的文件有： Test Strategy， Test Plan， Test Case， Test Report （test Bug tracking） 4. 建立测试管理体系的理论依据CMM(Capability Maturity Model)- 能力成熟度模型，是软件界的广泛使用的过程度量模型，旨在提升软件各个环节的作业标准，推动整个行业朝着更加规范，更加科学，也更加可控的方向发展。CMM是软件发展的必然产物，是被反复证明确实能帮助企业和产品提升自身竞争力的事实依据。也得到了国际上绝大多数软件厂商的认可和积极参与，获得CMM国际认证也成了各大软件公司的追求目标。既然如此，测试作为软件生产必不可少的一环，制定和CMM标准相匹配的测试管理体系就显得尤为重要了。事实上在测试界也有与之对称的标准，称之为TMM。废话少说，下面我简要介绍下TMMi和CMMi的相关规范和等级定义，了解和熟悉这些规则是管理测试团队的重要理论依据。 CMMi的五级定义： Initial （初始级）- 处于这个级别的组织，基本没有健全的软件工程管理制度。每件事情都是以 特殊的方法来做，事情的成败取决于团队成员的个人能力，具有很大的偶然性，人员变动，则一切都跟着改变，处处充满危机，软件生产随意性很大，基本无法可依，无章可循。 Repeatable （可重复级） - 在这一级别的团队，有些基本的软件项目管理行为，主要是参考之 前项目经验，借鉴一些具体措施，可以预防一些危机的发生。 Defined （已定义级）- 在这一级别的团队，已为软件的生产编制了完整的文档，软件过程管理 和技术方面都有明确的定义，也采取了评审的办法来保证软件的质量。对生产过程的管理具有随意性，并不能严格的管理过程。 Manage（已管理级） - 一个处于第4级的公司对每个项目都设定质量和生产目标。这两个量将被不断地测量，当 偏离目标太多时，就采取行动来修正。利用统计质量控制，管理部门能区分出随机偏离和有深刻含义的质量或生产目标的偏离 Optimizing （已优化级）—个第5级组织的目标是连续地改进软件过程。这样的组织使用统计质量和过程控制技术作为指导。从各个方面中获得的知识将被运用在以后的项目中，从而使软件过程融入了正反馈循环，使生产率和质量得到稳步的改进。达到该级的公司可自发的不断改进，防止同类缺陷二次出现。 TMMi的五级定义： 和CMMi类似，TMMi也分五个等级进行定义，其大意和CMMi相当，这是在软件测试白皮书上摘抄的定义 - Initia –Similar CMM, no plan and system to test activities. Random and no document tracing Phase Definition - Establish basic techniques and methods, develop testing and debugging goals Integration - Establish test organization, integration testing into the project lifecycle, establish technical trainingprogrammer and control and monitor testing Management and Measurement - Establish organizational review programmer; Establish test measurement programmer; software quality evaluation Optimization, defect prevention and quality control - use process data for defect prevention; quality control; Test process optimization Tmm 和 CMM类似，有些书上对他们的定义完全相同，他是在CMM的基础上发展而来的，目的是提高软件生产团队的效率，它只是一种形式测试，并不代表软件本身的质量，它是检验你的软件生产是否遵循了一定的程序，是否有相应的管理措施和监管措施，不涉及软件本身内容。只是检测程序的形式，是否有各种会议，步骤等，至于会议开了什么内容，没有任何关系。CMMi-5是最高水平，取得CMMi5的最多的国家是印度，但是印度的软件质量很差，这折射了这种形式测试的局限性. 作为测试管理者，不应该只局限于这些规范和标准，要根据各自公司的实际，制定符合自身阶段的测试体系。一味追求高等级的认证标准，很容易让测试流于形式，适得其反。 5. 如何开展敏捷软件测试活动上面介绍了如何建立软件测试体系和遵行的理论依据，这里我就自身经验，结合网上大咖的梳理，介绍下敏捷软件测试活动展开的具体步骤，仅供大家参考。 测试需求收集和整理本迭代中的所有需求（主要体现为新增功能和原有功能的修改），建议以在线文档（例如google的google docs, Tencent的协同办公软件）的方式管理每个迭代中的需求变化。通常需要对来自产品的需求进行一定程度的细化，细化到本产品的测试工程师能够清楚理解需要验证的点即可，同时测试需求通常需要与产品负责人和开发组确认（非正式评审）。 测试计划“一页纸（One Page）”的测试计划是一个很好的实践。测试计划中只需要包含本次迭代的目标，以及简单的时间和资源计划即可。 测试设计与执行敏捷测试中的测试设计与执行通常是交织在一起的，对于新功能，测试工程师通常通过对新功能的使用和尝试来了解之，然后为其设计测试用例并用脚本（手工测试用例或自动化脚本）的方式将其固定下来；而对于原有功能的测试主要依靠自动化测试来进行。在测试设计阶段，测试工程师需要维护验收测试，以保证其准确地反映了每个迭代的目标。推荐使用在线表格或是轻量的用例管理软件对用例进行管理，在自动化程度比较高的情况下，甚至可以直接依赖测试需求列表和自动化测试脚本，而无需创建手工用例集合。 测试评估总结测试评估总结意味着对每个迭代中进行的测试进行评估与总结。与传统的测试相同，敏捷测试中评估的主要目的同样是获得被测产品质量与测试质量的度量。 总之，敏捷的软件测试工作不要拘泥于形式和文档，要将TMM精神体现在测试思维和执行力上，最大限度的确保测试完整性和覆盖率。在此基础上再进一步完善测试流程和归档整理。]]></content>
      <categories>
        <category>测试管理</category>
      </categories>
      <tags>
        <tag>测试流程</tag>
        <tag>测试体系</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试管理修炼之Agile开发模式]]></title>
    <url>%2F2015%2F11%2F08%2F%E6%B5%8B%E8%AF%95%E7%AE%A1%E7%90%86%E4%BF%AE%E7%82%BC%E4%B9%8BAgile%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[1. Agile 开发的由来 -1234Agile方法即敏捷方法（agile methodologies）（也被称为轻量级方法，lightweight methodology），它是一组开发方法的统称。 随着技术的迅速发展和经济的全球化，软件开发出现了新的特点，即在需求和技术不断变化的情况下实现快节奏的软件开发，这就对生产率提出了很高的要求。ISO-9000、CMM、SPICE目前已被公认为软件质量保障方面的事实标准，但由于其强调管理和控制，追求项目的可预测性和过程状态的可视性，在提高生产率方面并未予以足够的重视，实施时一方面需要大量中间制品（过程文档）的制作，给开发人员带来很大负担，另一方面，追求可预测性与实际需求的模糊和快速变化不相协调。在此情况下，出现了一些新的开发方法。新的方法主要有Extreme Programming (简称XP)、SCRUM、Crystal Methodologies、Feature Driven Development(简称FDD)、Dynamic Systems Development Methodology(简称DSDM) 、Adaptive Software Development(简称ASD)、Pragmatic Programming等，统称轻载（Lightweight）方法，以区别于传统的开发方法（称重载方法，Heavyweight）。2001年2月，新方法的一些创始人在美国犹他州成立了Agile 联盟,将轻载方法正式更名为Agile方法，Agile有轻巧、机敏、活力的意思。Agile 方法目前还没有一个明确的定义，其特点是对软件生产率的高度重视，主要适用于需求模糊或快速变化下的、小型项目组的开发。有人称，Agile方法是在保证软件开发有成功产出的前提下，尽量减少开发过程中的活动和制品的方法，笼统的讲就是，&quot;刚刚好&quot;（Just enough），即开发中的活动及制品既不要太多也不要太少，在满足所需的软件质量要求的前提下，力求提高开发效率。 2. 为什么要Agile？通俗的解释为 - 客户成为开发团队中的一部分。 和所有其他形式的敏捷软件过程一样，Scrum有频繁的包含可以工作的功能的中间可交付成果。这使得客户可以更早的得到可以工作的软件，同时使得项目可以变更项目需求以适应不断变化的需求。 开发团队经常评估风险并制定缓解计划。在每一个阶段根据承诺进行风险缓解，监测和管理。 计划和模块开发要保持透明，让每一个人知道谁负责什么，以及什么时候完成。 参与者要经常开会以跟踪项目进展 – 平衡的（发布，客户，员工，过程）仪表板更新 – 利益所有者更新。你必须拥有预警机制，例如在可能延期交付时提出警告。 不要隐藏问题。认识到或说出任何没有预见到的问题并不会受到惩罚。在工作场所和工作时间内必须全身心投入。– 完成更多的工作并不意味着需要工作更长时间。 3. 敏捷开发的四个角色和四种会以 四个角色： Scrum master - 是Scrum教练和团队带头人，确保团队合理的运作Scrum，并帮助团队扫除实施过程中遇到的障碍。 Product Owner - 确定产品的方向和愿景，定义产品发布的内容、优先级及交付时间，为产品投资回报率负责。 Developer - 负责将每一个sprint 的 category、backlog 转化为具体实现的执行者 QA、tester - 负责确保每一个sprint迭代的质量和目标达成 四种会议： Scrum Planning Meeting - 主要进行需求解析，场景挑选并最终形成每个迭代的backlog item Standby Meeting - 每天的例行会议，形式不限，主要目的是梳理当天全流程中遇到的问题和下一步工作安排 Sprint Review Meeting - 在 Sprint 结束后，大家一起评审本次 Sprint 的产出。每个人都可以自由发表看法，协助产品负责人对未来工作做出最终决定。并根据实际情况，适度调整产品待办事项列表。 Retropective Meeting - 在每次Sprint迭代结束后，回顾一下团队在流程和沟通等方面的成效，有哪些做得不错，哪些需要改善，大家一起讨论，以期在下一个迭代做得更好。 4. Agile开发的Scrum模式实施及流程详解 -Scrum 是一个用于开发和维护复杂产品的框架 ，是一个增量的、迭代的开发过程。在这个框架中，整个开发过程由若干个短的迭代周期组成，一个短的迭代周期称为一个Sprint，每个Sprint的建议长度是2到4周(互联网产品研发可以使用1周的Sprint)。在Scrum中，使用产品Backlog来管理产品的需求，产品backlog是一个按照商业价值排序的需求列表，列表条目的体现形式通常为用户故事。Scrum团队总是先开发对客户具有较高价值的需求。在Sprint中，Scrum团队从产品Backlog中挑选最高优先级的需求进行开发。挑选的需求在Sprint计划会议上经过讨论、分析和估算得到相应的任务列表，我们称它为Sprint backlog。在每个迭代结束时，Scrum团队将递交潜在可交付的产品增量。 Scrum起源于软件开发项目，但它适用于任何复杂的或是创新性的项目。 Scrum是Agile开发的一种模式，Agile开发中远不止Scrum这种模式，只是这种模式是目前最能体现Agile精神并且广为接受的模式。 Agile scrum 常见开发流程 - 备注：以上内容整理自百度文档，本人稍作处理，不具原著权限。 http://www.scrumcn.com/agile/scrum-knowledge-library/scrum.html https://baike.baidu.com/item/Agile%E6%96%B9%E6%B3%95/8215988]]></content>
      <categories>
        <category>测试管理</category>
      </categories>
      <tags>
        <tag>测试管理</tag>
        <tag>agile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[性能测试之LR经典案例]]></title>
    <url>%2F2015%2F11%2F04%2F%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E4%B9%8BLR%E7%BB%8F%E5%85%B8%E6%A1%88%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[Performance 测试也是自动化测试的一个重点领域，了解和掌握这一部分内容，也是完善自动化测试技能的一个补充。Performance测试包含的内容很多，这可以从其支持的协议看出。但日常测试中往往集中在HTML，WebService等协议，这里我将以实际的测试用例来详细介绍如何利用LR（Load Runner）来实现这类Cases的性能测试。先来看几个Cases。 典型案例关于Web Service的案例，通常我们遇到最多的Cases类似于下面的步骤，这应该是Web Services的标准测试步骤了，也是PT中测试WebService最常用的步骤。先来了解下，后面再来看怎么脚本实现。 1. Case One – Step1： Get WSDL from URL、File、UDDI （http://mdm-itg.houston.hp.com:8180/customer-manager/services/CompetitorService?wsdl） Step2：Initialize Parameters with Customer IDs Step3：Execute Search operation to get the response 2. Case two –关于HTML的案例，这部分Cases包含的情况很多，主要是因为基于Html的操作很普遍，比喻页面登录，查找，比较，搜索等等，都是常见的测试，这里我也提炼了一些基本的步骤，不一定全面，但却是可以代表很大一部分基于Html操作的PT方案。 Step1：Get the URL for portal Step2：Login with account Step3：Initialize with Pramenters Step4：Execute Searching and get the response 上面两中情况的性能测试在软件测试中出现的比率很高。熟练理解和编写这类脚本可以让我们轻松对付performance测试中80%以上的Cases. （呵呵。。。别拍砖，个人就是这么认为的） 这部分内容要怎么介绍呢？采取类似于AT的，一个案例一个案例的说比较乏味，也不太容易理解。因为基本上就是脚本代码重复Copy和Review。不具有参考性。还是围绕这两类Cases步骤，以及与其相关的知识点逐一展开吧。 脚本设计Performance 测试不同于AT，通常我们主张用Recording的办法来录制脚本，这样做不仅可以节省时间，而且对脚本中的各种Action（如 .CSS , .Do，.Json或者Jave Script， Asp等等控件）能够很好的识别。对于脚本的维护也是显而易见的。请看下面的脚本实现。 For Case one – 1.）录制WebService脚本12345678910111213141516web_service_call( &quot;StepName=customSearchLookupService_101&quot;,&quot;SOAPMethod=CustomerLookupEnWebServiceService|CustomerLookupEnWebSe rvicePort|customSearchLookupService&quot;,&quot;ResponseParam=response&quot;,&quot;Service=CustomerLookupEnWebServiceService&quot;,&quot;ExpectedResponse=SoapResult&quot;,&quot;Snapshot=t1395726342.inf&quot;,BEGIN_ARGUMENTS,&quot;xml:customSearchLookupService1=&quot; &quot;&lt;customSearchLookupService1&gt;&quot; &quot;&lt;customerId&gt;&#123;CustomerId&#125;&lt;/customerId&gt;&quot; &quot;&lt;/customSearchLookupService1&gt;&quot;,END_ARGUMENTS,BEGIN_RESULT,END_RESULT,LAST); 注意Web_Service_Call 用法,从面试的语法可知，Web_Service_Call 通常由ExpectedResponsespecificationsStepName参数构成，其他的都是optional. 用户可以根据实际情况选择使用。每个参数的定义可以从Help文档中查询，（F1: 查询函数用法） 2.）设置Checkpoint1234getValuefromResponse = lr_xml_find(&quot;XML=&#123;response&#125;&quot;,&quot;Query=/Envelope[1]/Body[1]/customSearchLookupServiceResponse[1]/customerSearchLookup ResultGroup[1]/externalProfileGroup[1]/externalProfileLocatorBusinessLocatorNumber[1]/text()[1]&quot;, &quot;Value=0709898899&quot;, LAST); 3.）判断Checkpoint的条件1234567if (getValuefromResponse == 1)&#123; lr_end_transaction(&quot;RequestAndResponse&quot;, LR_PASS);&#125;else&#123; lr_end_transaction(&quot;RequestAndResponse&quot;, LR_FAIL);&#125;return 0; 录制和设置Chekcpioint部分可以直接使用LR的界面完成，第三部需要手工编写Checkpoint条件。根据函数的语法（参见上面3.2部分内容）其实也不难完成。 Note：再次体会LR C语法的基本特点，每条语句都以分号结束。小括号内的每一参数赋值均已逗号结束，并且每条语句必须以双引号引用起来。引用变量值使用大括号{ }。另外，如果双引号里的内容又是被上引号引用的，那么就需要用反斜杠 “/”进行转换。（这在LR的help文件里有详细说明） For Case Two –这部分脚本完全是手工编写的，目的就是如何利用上面介绍的函数来编写LR脚本。（如果可以录制的话，还是建议录制的办法，这里介绍的手工编写代码，仅供那些不能录制脚本的情况作为参考） 1.）Login URL123456789101112131415161718使用”Action Function – Web_Submit_Data“函数发送URL请求web_submit_data(&quot;login.pl&quot;, &quot;Action=https://it-services-itg.external.hp.com/auth/login.pl&quot;, &quot;Method=POST&quot;, &quot;RecContentType=text/html&quot;, &quot;Referer=&quot;, &quot;Snapshot=t5.inf&quot;, &quot;Mode=HTML&quot;, &quot;EncodeAtSign=YES&quot;, ITEMDATA, &quot;Name=action&quot;, &quot;Value=logon&quot;, ENDITEM, &quot;Name=deviceos&quot;, &quot;Value=2.0.0&quot;, ENDITEM, &quot;Name=devicetype&quot;, &quot;Value=TouchPad&quot;, ENDITEM, &quot;Name=deviceNDUID&quot;, &quot;Value=123&quot;, ENDITEM, &quot;Name=user&quot;, &quot;Value=your email address&quot;, ENDITEM, &quot;Name=password&quot;, &quot;Value=your nt account&quot;, ENDITEM, &quot;Name=osType&quot;, &quot;Value=WebOS&quot;, ENDITEM, LAST); 注意相关参数的设置，同样可以参考Help文档设置Web_Submit_Data函数。接下来就是Search操作了，由下面的函数实现。 2.）Search with the specified initialization1234567891011121314web_reg_find(&quot;Search=Body&quot;, &quot;SaveCount=findcount&quot;, &quot;Text=SDGT&quot;, LAST); status = web_url(&quot;rplAnywhere-web&quot;, &quot;URL=https://it-services-itg.external.hp.com/onebox/rplAnywhere- web_1_0_0/services/rpl?name=BIN%20LADEN&amp;countryCode=US&quot;, &quot;Resource=0&quot;, &quot;RecContentType=text/html&quot;, &quot;Referer=&quot;, &quot;Snapshot=t6.inf&quot;, &quot;Mode=HTML&quot;, LAST); 对照Web_URL语法，这里对三个必要参数赋值- Step Name, URL 和 Attribute list. 除了这个函数外，还可以用其他函数如 web_submit_data, web_URL 代替。他们都属于Action Function. 同样可达到发送URL请求的目的。 接下来就是Checkpoint检查了，代码如下 ) Checkpoint Setting and Validation12345678910111213lr_output_message(&quot;request status :%d&quot;, status);lr_output_message(&quot;find count :%d&quot;, atoi(lr_eval_string(&quot;&#123;findcount&#125;&quot;)));if (atoi(lr_eval_string(&quot;&#123;findcount&#125;&quot;)) &gt; 0)&#123;//check the times of finding &apos;SDGT&apos; string lr_output_message(&quot;found the value at the return page&quot;); lr_end_transaction(&quot;AdhocSearching&quot;, LR_PASS); &#125; else&#123; lr_output_message(&quot;found fail&quot;); lr_end_transaction(&quot;AdhocSearching&quot;, LR_FAIL); &#125;return 0; 此处的函数的理解可参考上面的解析。这里不再重复了。到此为止，两种案例的代码实现介绍完毕，是不是还是感觉云里雾里？很正常，这主要是因为LR的C实现函数参数太多，而且使用起来也不是很有感觉。 比喻说调用Web_Custom_request函数发送URL请求。那么函数Web_Custom_request到底该参数化哪些参数？每个参数的值该如何获取？还是没有一个直观的认识。这也是你尽管看了上面那些函数解析后后任然不知所措的根本所在。这是个难点。但我们有办法破解  方法一： 如何识别哪些方法需要被Action Function提取这是手工开发LR代码的必要步骤，你首先要知道哪些页面方法需要被Action Function提取，找出这些方法，然后调用Action Function函数予以实现。难就难在找出这些方法上。看好下面的介绍，解决上面问题的solution就要出来了 – 进入相关页面，进入代码视图，进入Network视图，反复操作页面，看哪些方法的response是关联下一个步骤的。把这些方法提出来，一 一调用Action Function 函数予以实现。 好了这就是要领 。(这里主要是针对record困难的Chrome环境。 按F12进入)不知道？还是不知道？那你打开一个GUI界面（IE或者Chrome都可以）进入代码视图模式，反复进行页面操作（如login），然后在Network视图里看看哪些方法被识别出来了，再看看这些方法的response，有哪些跟下一步骤的界面相关就提出来。这就是Action Function的函数要去实现的步骤。就这么简单。实在不会的话，就按照上面的介绍反复操练吧，知道熟练找出页面方法为止。 方法二： 如何识别哪些方法需要被Action Function提取请使用第三方工具来帮助提取。这里推荐使用Fiddler工具，这个工具可以很方便的看出页面操作对象以及方法属性。用它可以提高我们的代码开发效率，有兴趣的童鞋不妨试试。个人感觉还是不错的。使用它可以帮我们快速找出页面相关元素，以及相应方法，找到这些方法和元素后，跟方法 一 一样，我们需要将这些方法和元素以函数的形式表述出来。这就是LR C脚本开发应该遵行的规则。当然如果能record的话，还是建议大家record。毕竟系统自动抓出的方法和属性要比手工去添加的来得快和准。]]></content>
      <categories>
        <category>性能测试</category>
        <category>Performance Testing</category>
        <category>LR</category>
      </categories>
      <tags>
        <tag>性能测试</tag>
        <tag>Performance Testing</tag>
        <tag>LR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自动化测试流程]]></title>
    <url>%2F2015%2F09%2F24%2F%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[什么时候需要自动化测试这个问题几乎每个学习自动化的人都会遇到，答案也是各不相同，但问题本质上离不开这几个因素： 1.&gt; Test Times – if you often required to do regression test 2.&gt; Test Environment – if the test environment is stable 3.&gt; Reusable Repeat Operation – if your projects have the large of reusable repeat operation 4.&gt; Project release frequency – if your project is a long term project and if the release is frequency 5.&gt; Effort Measure – if the effort is measurable/calculate between manual and automation 基本上如果一个项目满足这些必要条件，那么自动化测试的优势就会比较明显，这也是衡量我们是否导入自动化测试的一个前置判断。另外，通过上面的分析，我们也很容易得出自动化测试的优缺点 – The merit of using Automation Test 1.&gt; It’s more convenient for regression test 2.&gt; It’s more quickly and efficiently to run the complex cases 3.&gt; It can take advantage of the resources well and make the people pay more attention to the jobs that more needs manual focus on 4.&gt; Reduce the mistakes of human caused 5.&gt; More accurate to simulate the manual test 6.&gt; Save effort The demerit of Automation 1.&gt; Automation不能完全代替Manual 2.&gt; Manual test 必定会比自动化测试发现更多的bug 3.&gt; 自动化测试对环境和相关前置条件的依赖比较大 4.&gt; 自动化测试没有Manual测试的想象空间大 5.&gt; 不要奢望自动化测试能帮助你发现所有的问题 自动化测试流程什么是自动化的测试流程？这也是每个学习自动化测试的人员必须面对和回答的问题， 做任何事情都必须遵循一定的准则。 自动化测试流程的作用就在如此。它是指导自动化测试的总体原则和自动化工作展开的参考依据。那么什么是自动化测试流程呢？简言之，如下图（图1-1自动化测试示意图） 图1-1 自动化测试示意图12345st=&gt;start: starte=&gt;end: endingop1=&gt; operation: caozuost-&gt;op1-&gt;e]]></content>
      <categories>
        <category>自动化测试</category>
      </categories>
      <tags>
        <tag>自动化测试</tag>
      </tags>
  </entry>
</search>
